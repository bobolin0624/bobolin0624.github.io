<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobo&#39;s Blog</title>
  
  
  <link href="https://bobolin0624.github.io/atom.xml" rel="self"/>
  
  <link href="https://bobolin0624.github.io/"/>
  <updated>2022-04-25T07:23:32.540Z</updated>
  <id>https://bobolin0624.github.io/</id>
  
  <author>
    <name>Bobo Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Note - 初探 JEST</title>
    <link href="https://bobolin0624.github.io/2022/02/21/note-jest-test/"/>
    <id>https://bobolin0624.github.io/2022/02/21/note-jest-test/</id>
    <published>2022-02-21T02:18:33.000Z</published>
    <updated>2022-04-25T07:23:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>給 JavaScript 開發者的測試框架，跟 React 整合性最佳！為什麼呢？大概因為 JEST 也是 Facebook 團隊開發的 (?)<br><br></p><span id="more"></span><p>這次主要會接觸到 JEST，是要在公司的專案裡頭試著導入，於是開始邊看邊實作，本篇就來簡單紀錄一點關於測試與 JEST 的基礎知識。</p><h4 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h4><p>這次主要是做單元測試，所謂單元測試，就是以專案中最小單位(function / method) 去驗證每個 function 可以輸出符合我們期望的回傳值。下面舉個最簡單的例子：</p><blockquote><p>有一 add function，會回傳 a + b，當測試時賦值 a = 1, b = 2 時， output 預期應該回傳 3，但卻得到回傳值為 5 時，就可以回頭去確認邏輯是不是寫成 a * 3 + b 之類的，進行 debug</p></blockquote><p><img src="https://miro.medium.com/max/1400/1*Dodv1f9UelXFsnZTXR81XA.png" alt="image alt"></p><br><h4 id="單元測試有什麼好處？"><a href="#單元測試有什麼好處？" class="headerlink" title="單元測試有什麼好處？"></a>單元測試有什麼好處？</h4><p>其實自己身邊遇過真的有在寫測試的工程師真的不多，畢竟每次收到需求時都已經是壓到不能再壓的時程（？，但其實這次嘗試寫測試時，發現還是有好處的，像是驗證基本錯誤、避免改 A 壞 B、降低人工測試時間成本等等，有句話說 “ Code for six minutes, debug for six hours! ” 我想應該很多開發者都有過類似的經驗吧 :face_with_monocle: </p><br><h4 id="JEST"><a href="#JEST" class="headerlink" title="JEST"></a>JEST</h4><p>雖然這次不是 React 專案而是 Node.js 後端使用 JEST 做測試，但在導入時我仍然覺得使用 JEST 來寫測試很快速也方便，先前在其他專案協作時使用 TDD 開發，使用的是 mocha 測試框架，mocha 本身斷言庫及測試替身需要再額外安裝 chai 及 sinon 套件，而 JEST 本身就包含了這些 library，因此整個導入上有速度快且容易的優勢，從安裝套件到開始寫測試大概花不到兩分鐘，可以參考以下步驟 ( JEST 的<a href="https://jestjs.io/docs/getting-started">官方文件 <span class="github-emoji"><span>📖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </a>算是淺顯易懂的，讓我這種不愛看官方文件的人也有耐心地翻閱了不少內容）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1) install package</span><br><span class="line">npm install jest --save-dev</span><br><span class="line">(2) 在 package.json 的 scripts 中多加一行 test，如此跑測試時就可以使用 npm run test</span><br><span class="line">{</span><br><span class="line">  "scripts": {</span><br><span class="line">    "test": "jest"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">(3) 新增 __tests__ 資料夾</span><br><span class="line">(4) 新增 xxx.test.js 檔</span><br></pre></td></tr></tbody></table></figure><p>基本上做完上面四個步驟後，接著就可以開始寫測試囉！</p><h5 id="測試怎麼寫？"><a href="#測試怎麼寫？" class="headerlink" title="測試怎麼寫？"></a>測試怎麼寫？</h5><p>以一個前些時間專案的 unit 為例，情境是每隔一段時間需要去判斷目前的工班是否已經換班，需要驗證的就是「是」或「否」這麼簡單</p><p>測試案例的撰寫，撰寫每一道測試需要先定義</p><ul><li>測試的目標為何？</li></ul><p>前一工班與現在工班是否換班(相同)，並回傳相同與不同的 result</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test('compare pre and now work is changed', () =&gt; {</span><br><span class="line">  測試程式</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>導入要測試的函式是什麼？</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareWork(pre, now)</span><br></pre></td></tr></tbody></table></figure><ul><li>測試的期望是什麼？</li></ul><p>希望測試 [未換班] 的結果，期望回傳的 result 的是 false</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(compareWork(pre, now)).toEqual({ result: false })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>JEST 中有很多 Matchers 可以使用如 toBe, toEqual, toBeTruthy …等等，可以依據測試案例去查找可用的 Matchers</p><p>這個 unit 的驗證還會有 [已換班] 的結果，此時就可以再繼續寫下一個案例來測試 [已換班] 啦。</p><h5 id="超方便的-Mock-替身"><a href="#超方便的-Mock-替身" class="headerlink" title="超方便的 Mock (替身)"></a>超方便的 Mock (替身)</h5><p>測試時需要關注點分離，我們常常都會在函式裡面又引入另一個函式，但是我們要專心在測試要被測試的 Function (SUT — System Under Test 測試目標)，這時候就需要排除不確定性（例如錯誤可能來自另一個函示），此時就可以使用 Mock 來當作替身函式 (Test Double)，模擬其他相依函式 (DOC -Depended-on Component 依賴組件) 的回傳值（類似做假資料的意思）。</p><p>可以選擇要把單一 function mock 起來，也可以 mock 我們要串外部 api 的 module 像是 axios 套件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mock function</span><br><span class="line">const mockFunction = jest.fn()</span><br><span class="line"></span><br><span class="line">// mock module</span><br><span class="line">jest.mock(‘../models/xxx’)</span><br><span class="line">jest.mock(‘axios’)</span><br></pre></td></tr></tbody></table></figure><p>接著就指定回傳值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 指定永久回傳值（也可以指定回傳某個值一次）</span><br><span class="line"></span><br><span class="line">mockFunction.mockReturnValue()</span><br><span class="line">axios.get.mockReturnValue(response)</span><br><span class="line">axios.mockReturnValue(response)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>最後，簡單分享在開發時解決的一個問題</p></blockquote><h6 id="環境變數"><a href="#環境變數" class="headerlink" title="環境變數"></a>環境變數</h6><p>問題情境：在測試某個 function 並且程式碼中有使用 axios 呼叫 api 時，由於我將 url 為透過 launch.json 存取執行 process.env 環境再取得 config.json 設定檔中的網址，雖然測試案例已經 mock axios module，不過跑測試時因為沒有讀取到環境變數，導致程式碼跑出 undefined 的值進行報錯，測試就無法順利往下跑。</p><p>這部分因為在程式碼中又牽扯到作用域的關係，於是花了一些時間在嘗試，最後在官方文件中發現了JEST 提供 setupFiles 設定，檔案中可以直接設定程式碼中需要的 config 與環境變數，如此一來在每次 npm run test 的時候就會使用這支檔案的變數內容囉。</p><p><img src="https://miro.medium.com/max/1400/0*vrpcNJ4HS1vP_adm" alt="image alt"></p><br><p><img src="https://miro.medium.com/max/1400/0*bdlPciJPxuFSgrDl" alt="image alt"></p><p>設定好後就在 .jest/setEnvVars.js 中加入 process.env 的相關變數就可以啦！</p><p>在這個問題情境下，解法或許還有一種就是使用 dotenv 的套件來存取，不過還沒有時間實作測試是否可行，還盼有高手及前輩分享經驗~~</p><h5 id="最後的最後"><a href="#最後的最後" class="headerlink" title="最後的最後"></a>最後的最後</h5><p>記錄一下自己首次從研究測試框架到導入的微心得</p><ul><li>藉以利用寫單元測試的過程，審視程式碼的維護性與完整性</li><li>寫單元測試更能理解寫出低藕合的 code 的好處，在高藕合程式碼的狀況下就必須使用大量 mock</li><li>必須儘量以不更動程式碼及邏輯為前提的狀態下寫測試，除非特例狀況或重構</li><li>測試程式也要有好的維護性與可讀性，須考量維護成本</li><li>專案中團隊的討論依然重要，包含寫測試的時間點、測試的粒度、規範等等（工程師們不要再逃避溝通啦～～～by ex-PM 的吶喊 😂）</li></ul><p><code>(初學程式筆記，若文中有誤還請不吝指教 ）</code><span class="github-emoji"><span>🤓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f913.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;給 JavaScript 開發者的測試框架，跟 React 整合性最佳！為什麼呢？大概因為 JEST 也是 Facebook 團隊開發的 (?)&lt;br&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://bobolin0624.github.io/categories/Note/"/>
    
    
    <category term="JavaScript" scheme="https://bobolin0624.github.io/tags/JavaScript/"/>
    
    <category term="JEST" scheme="https://bobolin0624.github.io/tags/JEST/"/>
    
  </entry>
  
  <entry>
    <title>Project - AWS 服務初體驗</title>
    <link href="https://bobolin0624.github.io/2021/10/28/project-aws-deploy-first-time/"/>
    <id>https://bobolin0624.github.io/2021/10/28/project-aws-deploy-first-time/</id>
    <published>2021-10-28T02:23:32.000Z</published>
    <updated>2022-04-25T07:23:44.268Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AWS <a href="https://aws.amazon.com/tw/elasticbeanstalk/">Elastic Beanstalk</a> 與 <a href="https://aws.amazon.com/tw/rds/">RDS</a> 服務部署網站</p><br><span id="more"></span><h5 id="Why-AWS"><a href="#Why-AWS" class="headerlink" title="Why AWS?"></a>Why AWS?</h5><p>部署在部分公司也成了工程師必備的技能之一，通常最常看到的就是 AWS ，當然還有 GCP 與 AZURE，不過 AWS 是這三大最早出現的，所以就先挑他來做練習。</p><h6 id="AWS-看起來包山包海的，所以他到底是什麼？-官網寫著："><a href="#AWS-看起來包山包海的，所以他到底是什麼？-官網寫著：" class="headerlink" title="AWS 看起來包山包海的，所以他到底是什麼？ 官網寫著："></a>AWS 看起來包山包海的，所以他到底是什麼？ 官網寫著：</h6><blockquote><p>Amazon Web Services 是全球最全面和廣泛採納的雲端平台，透過全球資料中心提供超過 200 項功能完整的服務。數百萬個客戶 — 包括成長最快的新創公司、最大型企業以及領先的政府機構 — 都使用 AWS 來降低成本、變得更靈活，且更迅速地創新。</p></blockquote><p>我想…就是提供各式各樣不同的雲端相關服務囉！</p><h5 id="開始吧"><a href="#開始吧" class="headerlink" title="開始吧"></a><strong>開始吧</strong></h5><p>基本上只要在 Google 輸入「Node.js 部署 AWS」應該點到這裡 =&gt; <a href="https://aws.amazon.com/tw/getting-started/hands-on/deploy-nodejs-web-app/">https://aws.amazon.com/tw/getting-started/hands-on/deploy-nodejs-web-app/</a></p><p>官網甚至提供中文的教學步驟 <span class="github-emoji"><span>📖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，我是依照使用「AWS Elastic Beanstalk 和 Amazon DynamoDB 啟動 Node.js Web 應用程式環境的教學」開始部署之旅，不過因為這次練習部署的站我使用的是 MySQL，所以我最後使用的是 Amazon RDS 的資料庫做連線，如果是使用 NoSQL 的話就使用 DynamoDB 即可。</p><p>Elastic Beanstalk 是 AWS 幫助開發者把 EC2 跟其他部署的建設基礎都處理好的類 PaaS 服務（理解有誤的話還有望前輩們指教），所以只要選好 server 方案、平台，上傳程式碼，就可以輕鬆部署完成。</p><p>因為部署並不複雜，且官網都有詳細說明，所以這篇就沒有一一寫出步驟，主要挑出有遇到的幾個小問題來分享：</p><br><ul><li><em><strong>.env 檔案 — 環境設定</strong></em></li></ul><p>這次練習的專案我有使用 Imgur 的 API 來做上傳圖片，如果專案有需要設定環境參數的話記得到「組態」的「環境屬性」做設定</p><p><img src="https://miro.medium.com/max/700/1*zht_hrS0BTuhRSkPz-umUA.png" alt="image alt"><br><br><br><img src="https://miro.medium.com/max/700/1*WhnG6-opD3MHWYJD62eQKw.png" alt="image alt"></p><br><ul><li><em><strong>有錢才能任性：建立 Database — region 也很重要</strong></em></li></ul><p>我在本機先使用了 MySQL 做開發，所以就選擇使用 Amazon RDS 來與應用程式串接</p><p><img src="https://miro.medium.com/max/700/1*H5fU4Fwa3wxJ8Vms32kjnA.png" alt="image alt"></p><p>這邊遇到的小坑是，我一開始建立專案選在 region 選了亞太地區(大阪)，結果建立 Database 的時候，怎麼選都沒看到 db.t2.micro 的免費方案（換了 MySQL 版本也是），最後請教了一下有經驗的人才發現，原來 region 不同服務跟計價也會有差異，後來改選到亞太地區(東京)才順利建立了免費試用的資料庫（目前免費專案也是只有第一年 750 hr / month 哦，之後要隨時注意一下 billing，以免被收費~)</p><br><ul><li><em><strong>專案部署設定</strong></em></li></ul><p>Elastic Beanstalk 部署可以用上傳檔案的方式，似乎也可以使用 EB CLI 與 Docker 的方式部署（之後再找機會嘗試），這次我是先使用了壓縮專案成 ZIP 檔案上傳的方式部署，專案先將 config.json 檔案的 production 設定完成後，將專案打包上傳，部署完後滿心期待點了網址卻一直出現轉圈圈的狀況，毫無頭緒的我，第一個想法是看 LOG 檔報了什麼錯，但在 AWS 上的 Log 去哪看呢？ 就在「日誌」裡頭，「請求日誌」點下去可以選擇要全部的還是只要 100 行，下載下來是個 ZIP 檔，解壓縮後找到 web.stdout.log 這個檔案，就可以看到 log 了 :+1: </p><p><img src="https://miro.medium.com/max/700/1*6eU6jvDlox75AR703Yn4jw.png" alt="image alt"></p><p>第一次出錯我看到 log 顯示的像是連線錯誤，查看了一下發現在 AWS 上應該是執行 <code>package.json</code> 中 <code>start</code> 腳本，於是我就將設定改成<br><code>"start": "NODE_ENV=production node app.js" </code>重新部署後，網站就成功跑起來了，不過對於這樣的連線問題還是有些疑惑存在，希望未來可以再慢慢補齊觀念。</p><p>這次部署到 AWS 的網站算是個人的 Portfolio [ 全端開發使用 Node.js + Express.js + Handlebars (版型取用網路上免費的 Bootstrap template 來做套版修改) ]，因為免費方案有限制因此純分享就不附上 demo 網址啦～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 AWS &lt;a href=&quot;https://aws.amazon.com/tw/elasticbeanstalk/&quot;&gt;Elastic Beanstalk&lt;/a&gt; 與 &lt;a href=&quot;https://aws.amazon.com/tw/rds/&quot;&gt;RDS&lt;/a&gt; 服務部署網站&lt;/p&gt;
&lt;br&gt;</summary>
    
    
    
    <category term="Project" scheme="https://bobolin0624.github.io/categories/Project/"/>
    
    
    <category term="AWS" scheme="https://bobolin0624.github.io/tags/AWS/"/>
    
    <category term="Elastic Beanstalk" scheme="https://bobolin0624.github.io/tags/Elastic-Beanstalk/"/>
    
    <category term="deploy" scheme="https://bobolin0624.github.io/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>雜記 - 回顧</title>
    <link href="https://bobolin0624.github.io/2021/10/28/diary-2021-review/"/>
    <id>https://bobolin0624.github.io/2021/10/28/diary-2021-review/</id>
    <published>2021-10-28T01:54:01.000Z</published>
    <updated>2022-04-25T07:31:50.792Z</updated>
    
    <content type="html"><![CDATA[<p>COVID-19 疫情的衝擊，除了被取消過四次航班外 <span class="github-emoji"><span>😿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，其餘安好！<br><span id="more"></span>感恩身旁的人如今還平安健康，這段時間多了許多跟自己的對話，再加上透過旁人的鼓勵，我終於踏出半個舒適圈，認真的考慮工程師的職位。</p><blockquote><p>所有你想做的事，現在就是你此生能最快開始的時間了</p></blockquote><h5 id="師父領進門"><a href="#師父領進門" class="headerlink" title="師父領進門"></a>師父領進門</h5><p>體會過 w3school、hahow 的線上課程，也曾巴著工程師朋友遠端教學，一直以來都是蜻蜓點水的碰觸程式語言，直到加入了 Bootcamp，才真正開始從基礎概念一路有系統性地前進。我一直在想這跟以前學吉他好像，我以為會五月天的擁抱就可以說我會彈吉他了，直到我真正上了課，爬了好長一段時間的音階才前進到和弦，這才慢慢真正深入的掌握如何彈吉他這件事。</p><p>前期在的 exercise 都還過得去的狀況，算是確立了喜歡 coding 這件事，我自己判定最簡單的方法就是看自己每天起床，會不會對於進度或作業感到厭煩想逃避，心想沒有這樣的念頭至少是不討厭吧～</p><p>後期開始接觸 Express 打造 Web app 及對資料庫 (MongoDB, MySQL) 的操作，慢慢發現自己對於畫面上呈現出正確的邏輯與資料富有成就感，在做 CRUD 時成功改動資料庫的瞬間，也很是滿意，因此沒想太多就選了專攻後端，對於選前/後端我覺得就像大學選科系一樣，一開始會怕後悔，但後來想想，以前我讀了商科，現在不也是來學寫程式了嗎？而我自商科畢業，做的工作所學到的經驗，那些也都不會是浪費，而是成為了養分。</p><blockquote><p>唯一能限制你的，只有你自己</p></blockquote><h5 id="修行在個人"><a href="#修行在個人" class="headerlink" title="修行在個人"></a>修行在個人</h5><p>從語法拼湊到運算邏輯，從大量手把手實作到靠自己上網找解法，從迴圈卡一天、非同步語法腦袋打結三天，到最後必須兩週完成協作開發專案，當然也有想放棄的時候，特別有段時間在醫院邊 coding 邊陪病的日子（辛酸畫面流出），最感謝的還是自己堅持了下來！</p><p>結束了自學課程，沒有了死線，而職涯漫漫、學海無涯，真正的個人修行才正要開始！</p><blockquote><p>學如逆水行舟，不進則退</p></blockquote><p><img src="https://imgur.com/R3cN4o7" alt="image alt"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;COVID-19 疫情的衝擊，除了被取消過四次航班外 &lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;😿&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f63f.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;，其餘安好！&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Diary" scheme="https://bobolin0624.github.io/categories/Diary/"/>
    
    
  </entry>
  
  <entry>
    <title>Project - Simple Twitter</title>
    <link href="https://bobolin0624.github.io/2021/10/03/project-simple-twitter/"/>
    <id>https://bobolin0624.github.io/2021/10/03/project-simple-twitter/</id>
    <published>2021-10-02T16:00:00.000Z</published>
    <updated>2022-05-13T05:47:44.768Z</updated>
    
    <content type="html"><![CDATA[<p>第一次以工程師的角色，開啟多人協作專案<br>一直以來在職場上都是以 PM 的角色開啟專案，終於在 coding bootcamp 中，最後以工程師的角色，加入了 Simple Twitter 協作專案。</p><span id="more"></span><h5 id="專案目標：在兩週時限內使用前後分離模式開發簡易推特社群網站"><a href="#專案目標：在兩週時限內使用前後分離模式開發簡易推特社群網站" class="headerlink" title="專案目標：在兩週時限內使用前後分離模式開發簡易推特社群網站"></a>專案目標：在兩週時限內使用前後分離模式開發簡易推特社群網站</h5><h5 id="開發語言與框架：前端使用-Vue，後端使用-Express-MySQL"><a href="#開發語言與框架：前端使用-Vue，後端使用-Express-MySQL" class="headerlink" title="開發語言與框架：前端使用 Vue，後端使用 Express + MySQL"></a>開發語言與框架：前端使用 Vue，後端使用 Express + MySQL</h5><h5 id="負責項目：後端開發（包含資料庫建置、後台功能與前台部分功能）與-API-部分文件撰寫"><a href="#負責項目：後端開發（包含資料庫建置、後台功能與前台部分功能）與-API-部分文件撰寫" class="headerlink" title="負責項目：後端開發（包含資料庫建置、後台功能與前台部分功能）與 API 部分文件撰寫"></a>負責項目：後端開發（包含資料庫建置、後台功能與前台部分功能）與 API 部分文件撰寫</h5><h3 id="專案-Kick-off-Meeting"><a href="#專案-Kick-off-Meeting" class="headerlink" title="專案 Kick-off Meeting"></a>專案 Kick-off Meeting</h3><p>夥伴們的線上相見歡，簡單互相認識後，很快速就訂定了幾項事務與目標：</p><ul><li><p>Git flow 協作流程：主要使用 master-develop-feature 三層架構，但由於先前都沒有協作經驗，所以前後端組員還是分頭開 repo 練習，雖然最後似乎還是沒有按照較正規的作法，但透過這次經驗對於 GIT 的流程又有更進一步的認識。</p></li><li><p>定時檢視並交流專案狀態：最後實作上很慶幸組員們幾乎是處於秒回狀態，因此在對焦與溝通上都很順暢。</p></li><li><p>協作工具：Slack (即時訊息分享與溝通）, Trello（開發進度與會議記錄）, Google Sheet（元件拆分、 API 分工、驗測劇本）</p></li><li><p>視訊會議：<a href="https://meet.jit.si/">Jitsi Meet</a>, Google Meet</p></li></ul><h4 id="與後端組員的協作"><a href="#與後端組員的協作" class="headerlink" title="與後端組員的協作"></a>與後端組員的協作</h4><p>之前習慣的寫法都是用 promise，這次特別與夥伴提出想要以 async /await 的方式練習開發，雖然使用不同的寫法也沒有衝突，不過最後還是商討統一寫法看起來程式碼會較一致；而資料庫由我建置後，夥伴定義種子資料，接著開發功能的分工，採用 controller 的分法（考量：檔案衝突點少，功能連貫，能避免更動同一支檔案），我先負責 admin 後台與 user 相關的 api，另一位後端則從 tweet, reply 下手，過程中都蠻順利，遇到問題都能即時討論做法並達成共識，在卡關時也能互相 cover 找到盲點。</p><p><em>好物推薦：<a href="https://simpletwitterapi1.docs.apiary.io/#reference">後端 API 文件</a>這次使用 apiary 撰寫，使用 markdown 語法很是方便，後期觀察前端串 api 時的提問後，發現提供給前端其實還需要更實際的狀態碼、回傳內容、body、Content-Type …等，越詳細就越能減少溝通成本！</em></p><h4 id="與前端組員的協作"><a href="#與前端組員的協作" class="headerlink" title="與前端組員的協作"></a>與前端組員的協作</h4><p>與前端的協作是專案中覺得最新奇與最富挑戰的地方，因為前端會先進行元件與切版的製作，而在開發 API 時只先依照設計稿及想像力來 query 並給予資料，利用 postman 測試加上跑測試檔綠燈後就先過，但在實際串接時才發現前端需要的資料或格式跟當初想像不同，因而需要做更多的討論或調整，很 respect 前端的介面與資料串接，最期待的就是夥伴們說 ok 的時候，看到畫面上有資料是一件很有成就感的事！</p><p><em>好物推薦：前期測試時考量到還需大量改動程式碼，因此前後端的串接測試時決議先使用 ngrok 工具（可以將 localhost 對應一組 http / https domain），簡單快速！</em></p><p><img src="https://miro.medium.com/max/1400/1*evTEi_tTkFuQwvJeQ3mvhQ.jpeg" alt="simple twitter ui"></p><hr><h4 id="黑客松"><a href="#黑客松" class="headerlink" title="黑客松"></a>黑客松</h4><p>在指定規格完成後，緊接著就是為期一整個週末的黑客松挑戰，其實在指定規格到期日前一晚，全組都還因為在做部分調整一起奮戰到半夜，但隔天大家還是很有毅力的上 google meets 即時邊讀 socket.io 的官方文件邊討論(瞎聊)，即使最後只完整做完挑戰一，但還是收穫很多也做得很開心！</p><p><em>專案心得</em></p><p>原先一直各種擔心這次的專案實作會做不完或是大卡關之類的，但實際投入後覺得其實協作專案除了技術力外，更多的時間講求的是團隊如何溝通、協調，順利的推動專案直到上線，因此要謝謝有緣的組員們讓我能有這次寶貴的經驗！</p><p><a href="https://github.com/shijia22/twitter-front-end-vue-2020">前端 Repo</a><br><a href="https://github.com/shijia22/twitter-api-2020">後端 Repo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一次以工程師的角色，開啟多人協作專案&lt;br&gt;一直以來在職場上都是以 PM 的角色開啟專案，終於在 coding bootcamp 中，最後以工程師的角色，加入了 Simple Twitter 協作專案。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="https://bobolin0624.github.io/categories/Project/"/>
    
    
    <category term="Node.js" scheme="https://bobolin0624.github.io/tags/Node-js/"/>
    
    <category term="Express.js" scheme="https://bobolin0624.github.io/tags/Express-js/"/>
    
    <category term="MySQL" scheme="https://bobolin0624.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Project - Expense Tracker</title>
    <link href="https://bobolin0624.github.io/2021/08/08/project-expense-tracker/"/>
    <id>https://bobolin0624.github.io/2021/08/08/project-expense-tracker/</id>
    <published>2021-08-08T02:18:33.000Z</published>
    <updated>2022-04-25T07:32:01.080Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Why-this-project"><a href="#Why-this-project" class="headerlink" title="Why this project"></a>Why this project</h4><p>在學習後端開發的路途中，CRUD (Create, Read, Update, Delete) 以及資料的處理是學習的必經路程<span id="more"></span>，為了多次的產出練習，除了一開始最常入門的 Todo-List 外，也思考生活上最常使用增刪改查的應用，因為自己每天都有使用記帳 app，所以也因此實作了簡單的 Web 版本。</p><h4 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h4><p>後端：Node.js + Express.js<br>登入機制： passport.js<br>資料庫：MongoDB + mongoose<br>前端： express-handlebars / Bootstrap<br>版本：Github<br>部署：heroku</p><h4 id="Challenges-and-sharing"><a href="#Challenges-and-sharing" class="headerlink" title="Challenges and sharing"></a>Challenges and sharing</h4><p>Bootstrap 的排版與 CRUD 的基本功能撰寫上，因為練習較多次的關係，相對是能掌握的部分！</p><p>但在 filter 分類的資料處理上，心中想著要考量若資料量過多造成的效能問題，所以就選擇 mongoose 提供的 aggregate 的方法，但一開始使用時並沒有看太多細節，後面要加上年/月的篩選條件優化時，就遇到了無法同時兼顧兩邊條件的設定，在觀摩了網路許多的實作經驗以及查找 aggregate 眾多語法後，才找了 $ne 來表示若某條件沒有被設定時，就找出全部資料的方式，有看到許多分享經驗的人說：程式有趣的地方在於有很多種方式可以達到一樣的效果或功能。而給自己的心態是，不求一下子就寫出最乾淨、俐落的程式碼，但求能一直保持學習精進的熱忱。</p><p>另一個是 seeder 的建立，因為有關聯的資料表，所以必須先執行 user 的建立，接著再建立資料對應給 user，使用 forEach去迭代 json 檔案，就會發生種子資料沒有建立完全的狀況，因此才知道是非同步處理的議題，程式寫到越後面執行的 task 越多，就開始面對了這個大魔王，目前對於非同步本身的概念上是理解的，但對於實作上的用法還是需要查找許多網路資料來跟著用，這次選用的是 Promise.all，在 Promise.all 中建立好一組陣列資料，來保證陣列裡的內容全部執行完畢再結束 seeder。</p><p>在使用 passport.js 提供身份驗證機制的 middleware 時，體會到練習使用第三方套件也是很重要的事，可以方便進行整個全局開發。從需求來規劃需要的功能，接著搜尋套件，閱讀大量文件，實作出想要的功能，一開始對於密麻的文件會完全不知道怎麼下手，遇到很多的挫折，所幸現在網路資源很多，不斷觀摩、嘗試，最後實作出來的成果也是會充滿不少成就感。</p><p><strong>expense-tracker 專案的 <a href="https://github.com/bobolin0624/expense-tracker">GitHub</a> 與 <a href="https://intense-spire-30373.herokuapp.com/users/login">Heroku</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Why-this-project&quot;&gt;&lt;a href=&quot;#Why-this-project&quot; class=&quot;headerlink&quot; title=&quot;Why this project&quot;&gt;&lt;/a&gt;Why this project&lt;/h4&gt;&lt;p&gt;在學習後端開發的路途中，CRUD (Create, Read, Update, Delete) 以及資料的處理是學習的必經路程&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="https://bobolin0624.github.io/categories/Project/"/>
    
    
    <category term="Node.js" scheme="https://bobolin0624.github.io/tags/Node-js/"/>
    
    <category term="Express.js" scheme="https://bobolin0624.github.io/tags/Express-js/"/>
    
    <category term="MongoDB" scheme="https://bobolin0624.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Note - 淺談使用者驗證 (user authentication)</title>
    <link href="https://bobolin0624.github.io/2021/08/06/note-user-authentication/"/>
    <id>https://bobolin0624.github.io/2021/08/06/note-user-authentication/</id>
    <published>2021-08-06T00:48:20.000Z</published>
    <updated>2022-04-25T07:31:45.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天瀏覽無數網站，相信大家都有在進入網站被彈跳視窗要求登入過的經驗。<br>當我們要到特定頁面或使用功能時，網站的伺服器收到了請求 (request)，此時 server 會去確認我們有沒有權限可以瀏覽，<span id="more"></span>如果要使用的功能需要會員才能使用，此時我們就會被要求進行登入，如果當下你還沒有註冊過網站（意指資料還沒有被儲存在網站伺服器的資料庫中），那就必須先註冊才行。</p></blockquote><br><p>而 HTTP 本身是無狀態的服務，，每次收到一筆新請求想要進入該網站，都會認為是一個新的人（就像沒有會員制度的健身房一樣，運動的人來來去去，場館人員也不會知道你昨天來過），在這樣的狀況下，解決方法就是運用 session &amp; cookie 機制讓請求進來的人帶著憑證（建立會員制)。</p><p><em>註冊：提供個人資料，然後向網站請求註冊，這時候伺服器會向資料庫確認你的資料有沒有存在於資料庫中，如果沒有，就會建立一筆新資料。</em></p><ul><li>下定決心要減肥了，第一步是加入健身房的會員，填寫完個人資料還有拿出錢包後💵，櫃檯人員先到系統查詢了一下，發現會員中沒有你的資料，於是他幫你建立了一筆新資料，新做一張專屬於你的會員卡。</li></ul><p><em>登入：註冊後進行登入就可以使用網站功能了，登入時必須提供 ID及密碼給網站，讓伺服器到資料庫驗證帳號密碼，比對成功，這時回應成功的時候伺服器會建立 session，並傳送一組 session id，這組 session id 會保存在瀏覽器的 cookie 上，且必須加密保護。</em></p><ul><li>加入會員的隔天，馬上就到健身房報到，將會員卡交給櫃台人員驗證身份(驗證帳號密碼)，確認你是本人後(比對成功)，給了你一條毛巾和手環 (session id)，告知你在今天穿梭不同場館入口時都要出示手環，這時候你就可以靠著手上的手環選擇去有氧教室或是去重訓區。</li></ul><p><em>登出：離開網站時，為了避免被人使用，做了登出的動作，這時登出後 session id 會被消滅掉，下次再進入網站時，伺服器需要再重新驗證你的身份，因此必須重新登入。</em></p><ul><li>終於將今天的健身菜單完成了，在梳洗完畢後準備離開健身房，將手環歸還給櫃檯人員(消滅 session id)，如果下次要再進來時就必須再拿出會員卡讓人員重新比對(登入)，拿到新的手環後才能入場。</li></ul><p><img src="https://i.imgur.com/Q2wERwY.png" alt="圖解 user authentication"></p><p><code>(初學程式筆記，若文中有誤還請不吝指教 ）</code><span class="github-emoji"><span>🤓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f913.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天瀏覽無數網站，相信大家都有在進入網站被彈跳視窗要求登入過的經驗。&lt;br&gt;當我們要到特定頁面或使用功能時，網站的伺服器收到了請求 (request)，此時 server 會去確認我們有沒有權限可以瀏覽，&lt;/p&gt;&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Note" scheme="https://bobolin0624.github.io/categories/Note/"/>
    
    
    <category term="session" scheme="https://bobolin0624.github.io/tags/session/"/>
    
    <category term="cookie" scheme="https://bobolin0624.github.io/tags/cookie/"/>
    
    <category term="authentication" scheme="https://bobolin0624.github.io/tags/authentication/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Note - 淺談 Event Loop</title>
    <link href="https://bobolin0624.github.io/2021/05/12/note-js-event-loop/"/>
    <id>https://bobolin0624.github.io/2021/05/12/note-js-event-loop/</id>
    <published>2021-05-12T02:18:33.000Z</published>
    <updated>2022-04-25T07:23:40.032Z</updated>
    
    <content type="html"><![CDATA[<h4 id="從-Javascript-的特性說起：Single-Threaded"><a href="#從-Javascript-的特性說起：Single-Threaded" class="headerlink" title="從 Javascript 的特性說起：Single Threaded"></a>從 Javascript 的特性說起：Single Threaded</h4><p>Javascript 是一種單線程（單執行緒）的語言，程式碼會在 Stack 中被一一執行。</p><span id="more"></span><p><del>講中文：</del><br>一次只能做一件事</p><h5 id="又有新的名詞了：堆疊-Stack"><a href="#又有新的名詞了：堆疊-Stack" class="headerlink" title="又有新的名詞了：堆疊 (Stack)"></a>又有新的名詞了：堆疊 (Stack)</h5><p>維基百科說：堆疊（stack）又稱為棧或堆棧，是電腦科學中的一種抽象資料型別，只允許在有序的線性資料集合的一端（稱為堆疊頂端，top）進行加入資料（push）和移除資料（pop）的運算。因而按照後進先出（LIFO, Last In First Out）的原理運作。</p><p><del>講中文：</del><br>試看下圖生活中發生的例子，最先洗好的杯子放最下面，但要用的時候是拿最上面最後洗好的杯子，堆疊即是如此。</p><p><img src="https://miro.medium.com/max/1400/0*7DZA8far6AEXEKIP" alt="Photo by Crissy Jarvis on Unsplash"></p><blockquote><p>photo from medium - by Crissy Jarvis on Unsplash</p></blockquote><h5 id="阻塞-blocking"><a href="#阻塞-blocking" class="headerlink" title="阻塞 (blocking)"></a>阻塞 (blocking)</h5><p>上面提到一次做一件事，而如果這件事又要做很久，後面的事情就只能一直等，這樣的情況就稱為阻塞行為。</p><hr><h4 id="非同步處理-Asynchronous-Callbacks-＆-Task-Queue-amp-Event-Loop"><a href="#非同步處理-Asynchronous-Callbacks-＆-Task-Queue-amp-Event-Loop" class="headerlink" title="非同步處理 (Asynchronous Callbacks) ＆ Task Queue &amp; Event Loop"></a>非同步處理 (Asynchronous Callbacks) ＆ Task Queue &amp; Event Loop</h4><p>如何解決上述的情況呢？</p><p>JavaScript 的 runtime engine 一次只能做一件事，但瀏覽器可以同時執行很多件事，而且提供了 API 讓大家使用，讓程式可以透過 event loop 搭配非同步處理達到同時處理多件事。<br>整體的流程大概是這樣：</p><p>下面的有一段 JS 的程式碼，JS 處理程序會先依序將程式碼放入 Stack 中執行，所以執行了 <code>console.log(‘hello’)</code>，印出了 hello</p><p><img src="https://miro.medium.com/max/1400/1*NzpU75qlUlwBZtKUlnaP6A.png"></p><p>接著 Stack 執行 setTimeout function，但是 setTimeout 是屬於瀏覽器提供的 api，因此會被放到 web apis 的計時器中，等到設定的時間到了後（注意即使設定 0 秒還是會走這樣的流程），再把它放到 task queue 中等待，等到所有 Stack 清空後，才會立即執行。</p><p><img src="https://miro.medium.com/max/1400/1*RVbrJMFlCVUHZe-qHuPg7w.png"></p><p>所以接下來，會先執行 <code>console.log(‘World’)</code>，印出 World（注意 task queue 中的 setTimeout 還在等待中）。</p><p><img src="https://miro.medium.com/max/1400/1*HUp4Y2quWzqR1zOFAyxOHw.png"></p><p>最後進入 event loop ，event loop 會去判斷如果 stack 已經沒有東西就把 task queue 中的項目依序放到 stack 當中，執行該做的事。</p><p><img src="https://miro.medium.com/max/1400/1*CwT05pQah-f5V4AkJha1HA.png"></p><hr><h5 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h5><blockquote><p><em><strong>事件迴圈 Event Loop</strong></em></p></blockquote><p>是個監測員，監測 Call Stack 及 task queue</p><p>如果 stack 沒事件執行，且 task queue 有東西，那就將 task queue 移到 stack 執行。</p><p>如此不斷循環~~~~~</p><p><em>Reference</em></p><div class="video-container"><iframe src="https://www.youtube.com/embed/8aGhZQkoFbQ" frameborder="0" loading="lazy" allowfullscreen=""></iframe></div><p><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a></p><p><code>(初學程式筆記，若文中有誤還請不吝指教 ）</code><span class="github-emoji"><span>🤓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f913.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;從-Javascript-的特性說起：Single-Threaded&quot;&gt;&lt;a href=&quot;#從-Javascript-的特性說起：Single-Threaded&quot; class=&quot;headerlink&quot; title=&quot;從 Javascript 的特性說起：Single Threaded&quot;&gt;&lt;/a&gt;從 Javascript 的特性說起：Single Threaded&lt;/h4&gt;&lt;p&gt;Javascript 是一種單線程（單執行緒）的語言，程式碼會在 Stack 中被一一執行。&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://bobolin0624.github.io/categories/Note/"/>
    
    
    <category term="JavaScript" scheme="https://bobolin0624.github.io/tags/JavaScript/"/>
    
    <category term="event Loop" scheme="https://bobolin0624.github.io/tags/event-Loop/"/>
    
  </entry>
  
</feed>
